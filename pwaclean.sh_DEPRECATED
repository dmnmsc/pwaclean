#!/bin/bash
#
# This script has been replaced by the Python version.
# Please use 'pwaclean.py' instead.
#
# Este script ha sido reemplazado por la versi√≥n de Python.
# Por favor, usa 'pwaclean.py' en su lugar.
#

echo "--------------------------------------------------------" >&2
echo "‚ö†Ô∏è  NOTICE: This script (pwaclean.sh) is deprecated." >&2
echo "   Please use the new Python version: pwaclean.py" >&2
echo "--------------------------------------------------------" >&2

exit 1

set -u

# Relaunch in terminal if not interactive
if [[ ! -t 1 ]]; then
  if [[ "${XDG_CURRENT_DESKTOP:-}" == *KDE* ]]; then
    TERMINAL_EMULATOR=$(command -v konsole || true)
  elif [[ "${XDG_CURRENT_DESKTOP:-}" == *GNOME* ]]; then
    TERMINAL_EMULATOR=$(command -v gnome-terminal || true)
  else
    TERMINAL_EMULATOR=$(command -v x-terminal-emulator || command -v gnome-terminal || command -v konsole || command -v xfce4-terminal || command -v xterm || true)
  fi

  if [ -n "$TERMINAL_EMULATOR" ]; then
    "$TERMINAL_EMULATOR" -e bash -c "$0; echo; read -n 1 -s -r -p ' Press any key to close this window...'"
    exit
  else
    echo "‚ùå Could not find a terminal emulator to relaunch."
    exit 1
  fi
fi

# Configuration & defaults
BASE_DIR="$HOME/.local/share/firefoxpwa/profiles"
CONFIG_FILE="$HOME/.local/share/firefoxpwa/config.json"
AUTO_CONFIRM=false
CLEAN_ALL=false
DRY_RUN=false
REMOVE_EMPTY=false

# Directories considered safe to clear inside each profile
readonly CLEAN_DIRS=("cache2" "startupCache" "offlineCache" "jumpListCache" "minidumps" "saved-telemetry-pings" "datareporting")

# Argument parsing
for arg in "$@"; do
  case "$arg" in
    --yes|-y) AUTO_CONFIRM=true ;;
    --all|-a) CLEAN_ALL=true ;;
    --yes-all|-ya|-ay) AUTO_CONFIRM=true; CLEAN_ALL=true ;;
    --dry-run) DRY_RUN=true ;;
    --empty|-e) REMOVE_EMPTY=true ;;
    --help|-h)
      cat <<EOF
FirefoxPWA Cache Cleaner

Usage: pwaclean [options]

Options:
  --all, -a        Clean all profiles
  --yes, -y        Skip confirmation prompts
  --yes-all, -ya   Clean all profiles without confirmation
  --dry-run        Show actions without executing (no deletions)
  --empty, -e      Delete empty profiles (no apps installed)
  --help, -h       Show this help
EOF
      exit 0
      ;;
    *) echo "‚ö†Ô∏è Unknown option: $arg"; exit 1 ;;
  esac
done

# Environment checks
if [ ! -d "$BASE_DIR" ]; then
  echo "‚ùå Profile directory not found: $BASE_DIR"
  exit 1
fi
if [ ! -f "$CONFIG_FILE" ]; then
  echo "‚ùå config.json not found: $CONFIG_FILE"
  exit 1
fi
command -v jq >/dev/null 2>&1 || { echo "‚ùå 'jq' is required. Install with: sudo apt install jq"; exit 1; }
command -v firefoxpwa >/dev/null 2>&1 || { echo "‚ùå 'firefoxpwa' is required. Install it (e.g. pip install firefoxpwa)"; exit 1; }
command -v numfmt >/dev/null 2>&1 || { echo "‚ùå 'numfmt' is required (coreutils)"; exit 1; }

# Helper: humanize a byte size safely
humanize_size() {
  local bytes="$1"
  if ! [[ "$bytes" =~ ^[0-9]+$ ]]; then
    bytes=0
  fi
  numfmt --to=iec "$bytes" 2>/dev/null || echo "0"
}

# Process --empty: detect and optionally remove empty profiles
if $REMOVE_EMPTY; then
  echo "üîç Scanning for empty profiles..."
  EMPTY_PROFILES=()

  # collect profile IDs from JSON excluding default
  mapfile -t ALL_PROFILE_IDS < <(jq -r '.profiles | keys[] | select(. != "00000000000000000000000000")' "$CONFIG_FILE")

  for ID in "${ALL_PROFILE_IDS[@]}"; do
    NAME=$(jq -r --arg ulid "$ID" '.profiles[$ulid].name // ""' "$CONFIG_FILE")
    APP_IDS=$(jq -r --arg ulid "$ID" '.profiles[$ulid].sites[]?' "$CONFIG_FILE")
    PROFILE_PATH="$BASE_DIR/$ID"

    # count apps robustly
    if [ -z "$APP_IDS" ]; then
      APP_COUNT=0
    else
      APP_COUNT=$(printf '%s\n' "$APP_IDS" | grep -c .
    )
    fi

    # empty if no apps AND (no folder OR folder empty)
    if [ "$APP_COUNT" -eq 0 ] && { [ ! -d "$PROFILE_PATH" ] || [ -z "$(ls -A "$PROFILE_PATH" 2>/dev/null)" ]; }; then
      EMPTY_PROFILES+=("$ID::$NAME")
    fi
  done

  if [ ${#EMPTY_PROFILES[@]} -eq 0 ]; then
    echo "‚ÑπÔ∏è No empty profiles found."
  else
    echo "üìÇ Found ${#EMPTY_PROFILES[@]} empty profile(s):"
    for entry in "${EMPTY_PROFILES[@]}"; do
      IFS="::" read -r ID NAME <<< "$entry"
      echo " - $NAME ($ID)"
    done
    echo

    # require confirmation unless auto-confirm
    if ! $AUTO_CONFIRM; then
      read -p "‚ùì Delete these profiles? (Y/n): " yn
      yn="${yn:-y}"
      echo
      if [[ ! "$yn" =~ ^[Yy]$ ]]; then
        echo "üö´ Skipping empty profile removal."
      else
        # perform deletions
        for entry in "${EMPTY_PROFILES[@]}"; do
          IFS="::" read -r ID NAME <<< "$entry"
          if $DRY_RUN; then
            echo "üëÄ Would delete profile: $NAME ($ID)"
          else
            if firefoxpwa profile remove "$ID"; then
              echo "‚úÖ Deleted profile: $NAME ($ID)"
            else
              echo "‚ö†Ô∏è Failed to delete profile: $NAME ($ID)"
            fi
          fi
        done
      fi
    else
      # auto-confirm path
      for entry in "${EMPTY_PROFILES[@]}"; do
        IFS="::" read -r ID NAME <<< "$entry"
        if $DRY_RUN; then
          echo "üëÄ Would delete profile: $NAME ($ID)"
        else
          if firefoxpwa profile remove "$ID"; then
            echo "‚úÖ Deleted profile: $NAME ($ID)"
          else
            echo "‚ö†Ô∏è Failed to delete profile: $NAME ($ID)"
          fi
        fi
      done
    fi
  fi

  echo
  if ! $CLEAN_ALL && [ "$#" -eq 0 ] && [ "$DRY_RUN" = false ]; then
    :
  fi
fi

# Scan and collect profiles & their cache sizes
echo "üîç Scanning FirefoxPWA caches..."
echo

declare -A PROFILE_IDS
declare -A PROFILE_NAMES
declare -A PROFILE_SIZES
INDEX=1
TOTAL_SIZE=0

for PROFILE in "$BASE_DIR"/*; do
  [ -d "$PROFILE" ] || continue
  PROFILE_ID=$(basename "$PROFILE")

  # Skip the default profile (never touch)
  if [ "$PROFILE_ID" = "00000000000000000000000000" ]; then
    continue
  fi

  NAME=$(jq -r --arg ulid "$PROFILE_ID" '.profiles[$ulid].name // "(unnamed)"' "$CONFIG_FILE")

  # Sum cache directory sizes (bytes) using CLEAN_DIRS
  SIZE=0
  for DIR in "${CLEAN_DIRS[@]}"; do
    if [ -d "$PROFILE/$DIR" ]; then
      DIR_SIZE=$(du -sb "$PROFILE/$DIR" 2>/dev/null | awk '{print $1}')
      SIZE=$((SIZE + DIR_SIZE))
    fi
  done

  # Ensure SIZE is numeric
  [[ "$SIZE" =~ ^[0-9]+$ ]] || SIZE=0
  HUMAN_SIZE=$(humanize_size "$SIZE")

  # Count installed apps in profile
  APP_IDS=$(jq -r --arg ulid "$PROFILE_ID" '.profiles[$ulid].sites[]?' "$CONFIG_FILE")
  APP_COUNT=$(printf '%s\n' "$APP_IDS" | grep -c .)

  # Offer to remove truly empty profiles
  if [ "$SIZE" -eq 0 ] && [ "$APP_COUNT" -eq 0 ]; then
    echo "‚ö†Ô∏è Profile '$NAME' ($PROFILE_ID) is empty (no apps, no cache)."
    if ! $AUTO_CONFIRM; then
      read -rp "Do you want to remove it now? [y/N]: " CONFIRM
    else
      CONFIRM="y"
    fi
    if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
      if $DRY_RUN; then
        echo "üëÄ Would remove profile: $NAME ($PROFILE_ID)"
      else
        if firefoxpwa profile remove "$PROFILE_ID"; then
          echo "üóëÔ∏è Removed profile: $NAME ($PROFILE_ID)"
        else
          echo "‚ö†Ô∏è Failed to remove profile: $NAME ($PROFILE_ID)"
        fi
      fi
    else
      echo "Skipping removal of $NAME"
    fi
    continue
  fi

  # Store profile info for later cleaning
  PROFILE_IDS[$INDEX]="$PROFILE_ID"
  PROFILE_NAMES[$INDEX]="$NAME"
  PROFILE_SIZES[$INDEX]="$SIZE"

  # Print profile info
  echo "$INDEX) $NAME ($PROFILE_ID): $HUMAN_SIZE"
  if [ "$APP_COUNT" -gt 1 ]; then
    for APP_ID in $APP_IDS; do
      APP_NAME=$(jq -r --arg id "$APP_ID" '.sites[$id].manifest.name // .sites[$id].config.name // "(unnamed)"' "$CONFIG_FILE")
      echo "   - $APP_NAME"
    done
  fi

  TOTAL_SIZE=$((TOTAL_SIZE + SIZE))
  INDEX=$((INDEX + 1))
done

HUMAN_TOTAL=$(humanize_size "$TOTAL_SIZE")
echo
echo "üì¶ Total removable cache: $HUMAN_TOTAL"
echo

# Cleaning functions & confirmation
clean_profile() {
  local PROFILE_PATH="$BASE_DIR/$1"
  for DIR_NAME in "${CLEAN_DIRS[@]}"; do
    DIR="$PROFILE_PATH/$DIR_NAME"
    if [ -d "$DIR" ]; then
      if $DRY_RUN; then
        echo "üëÄ Would remove all contents of: $DIR"
      else
        rm -rf "$DIR"/*
      fi
    fi
  done
}

confirm_clean() {
  local NAME="$1"
  if $AUTO_CONFIRM; then
    return 0
  fi
  while true; do
    read -p "‚ùì Do you want to clean '$NAME'? (Y/n): " yn
    yn="${yn:-y}"
    case $yn in
      [Yy]*) return 0 ;;
      [Nn]*) return 1 ;;
      *) echo "‚ö†Ô∏è Please answer y or n." ;;
    esac
  done
}

# Ask which profiles to clean (unless --all)
if $CLEAN_ALL; then
  SELECTION=("a")
else
  if [ "${#PROFILE_IDS[@]}" -eq 0 ]; then
    echo "‚ÑπÔ∏è No profiles available to clean."
    exit 0
  fi
  read -p "Enter the numbers of the apps to clean (e.g. 1 3 5, 'a' for all, 'n' for none): " -a SELECTION
  echo
fi

echo "üßπ Cleaning selected apps caches..."
echo
CLEARED=0

if $CLEAN_ALL || [[ "${SELECTION[0]}" =~ ^(a|\*)$ ]]; then
  if ! $AUTO_CONFIRM; then
    read -p "‚ùì Do you want to clean *all* apps? (Y/n): " yn
    yn="${yn:-y}"
    if [[ ! "$yn" =~ ^[Yy]$ ]]; then
      echo "üö´ Cancelled cleaning all apps."
      exit 0
    fi
  fi
  for NUM in "${!PROFILE_IDS[@]}"; do
    PROFILE_ID="${PROFILE_IDS[$NUM]}"
    NAME="${PROFILE_NAMES[$NUM]}"
    SIZE="${PROFILE_SIZES[$NUM]}"
    if $DRY_RUN; then
      echo "üëÄ Would clean: $NAME"
    else
      clean_profile "$PROFILE_ID"
      CLEARED=$((CLEARED + SIZE))
      echo "‚úî $NAME cleaned"
    fi
  done
elif [[ "${SELECTION[0]}" =~ ^(n|N)$ ]]; then
  echo "üö´ No apps selected. Nothing was cleaned."
  exit 0
else
  for NUM in "${SELECTION[@]}"; do
    PROFILE_ID="${PROFILE_IDS[$NUM]}"
    NAME="${PROFILE_NAMES[$NUM]}"
    SIZE="${PROFILE_SIZES[$NUM]}"
    if [ -n "$PROFILE_ID" ]; then
      if confirm_clean "$NAME"; then
        if $DRY_RUN; then
          echo "üëÄ Would clean: $NAME"
        else
          clean_profile "$PROFILE_ID"
          CLEARED=$((CLEARED + SIZE))
          echo "‚úî $NAME cleaned"
        fi
      else
        echo "‚è≠ Skipped: $NAME"
      fi
    else
      echo "‚ö†Ô∏è Invalid selection: $NUM"
    fi
  done
fi

HUMAN_CLEARED=$(humanize_size "$CLEARED")
echo
echo "‚úÖ Total cache cleared: $HUMAN_CLEARED"
